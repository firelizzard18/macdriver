package main

import (
	"flag"
	"fmt"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"sort"
	"strings"
	"text/template"
)

const fileTemplate = `package {{ .Package }}

// Code generated by 'go run ../internal/cmd/gensend'. DO NOT EDIT.

import "unsafe"

// #cgo LDFLAGS: -lobjc
// #include <objc/message.h>
//
{{ range .Items }}// typedef {{ .C.Return }} (*_{{ .Name }})(id self, SEL cmd{{ range .C.Params }}, {{ . }}{{ end }});
{{ end }}//
{{ range .Items }}// {{ .C.Return }} send{{ .Name }}(id self, SEL cmd{{ range .C.Params }}, {{ . }}{{ end }}) { {{ if not .VoidReturn }}return {{ end }}((_{{ .Name }})&objc_msgSend)(self, cmd{{ range .C.Call }}, {{ . }}{{ end }}); }
{{ end }}//
import "C"

func objectGo2C(v Object) C.id { return C.id(unsafe.Pointer(v.Pointer())) }
func classGo2C(v Class) C.Class { return C.Class(unsafe.Pointer(v.Pointer())) }
func selectorGo2C(v Selector) C.SEL { return C.SEL(v.Pointer()) }

func objectC2Go(v C.id) Object { return ObjectPtr(uintptr(unsafe.Pointer(v))) }
func classC2Go(v C.Class) Class { return ClassPtr(uintptr(unsafe.Pointer(v))) }
func selectorC2Go(v C.SEL) Selector { return SelectorPtr(unsafe.Pointer(v)) }

{{ range .Items }}
// Send{{ .Name }} calls objc_msgSend with type encoding {{ .Encoding }}.
// WARNING! This may crash if the method's signature does not match.
func Send{{ .Name }}(self Object, cmd Selector{{ range .Go.Params }}, {{ . }}{{ end }}) {{ .Go.Return }} {
	{{ range .Conversions }}{{ . }}
	{{ end }}{{ if not .VoidReturn }}r := {{ end }}C.send{{ .Name }}(objectGo2C(self), selectorGo2C(cmd){{ range .Go.Call }}, {{ . }}{{ end }}){{ if not .VoidReturn }}
	return {{ .ConvertReturn }}{{ end }}
}
{{ end }}

func sendMsgDirect(self Object, cmd Selector, encoding string, args []interface{}) (Object, bool) {
	switch encoding { {{ range .Items }}
	case "{{ .Encoding }}":
		{{ if not .VoidReturn }}r := {{ end }}Send{{ .Name }}(self, cmd{{ range .DirectParams }}, {{ . }}{{ end }}){{ if .VoidReturn }}
		return notAnObject{value: struct{}{}}, true{{ else if .ObjectReturn }}
		return r, true{{ else }}
		return notAnObject{value: r}, true{{ end }}{{ end }}
	}
	return nil, false
}
`

type Data struct {
	Package string
	Items   []*Item
}

type Item struct {
	Name          string
	Encoding      string
	VoidReturn    bool
	ObjectReturn  bool
	Conversions   []string
	ConvertReturn string
	DirectParams  []string
	C, Go         Lang
}

type Lang struct {
	Return  string
	Params  []string
	Call    []string
	Convert []string
}

var packageName = flag.String("package", "", "Package name for generated file")
var filePath = flag.String("file", "", "File path to write to")
var itemCount = flag.Int("count", 0, "Create functions for the top N method signatures")
var onlyNSObject = flag.Bool("only-nsobject", true, "Only count methods of classes derived from NSObject")

func main() {
	flag.Parse()

	if *itemCount == 0 {
		println("Missing --count")
		os.Exit(1)
	}

	if *packageName == "" {
		println("Missing --package")
		os.Exit(1)
	}

	if *filePath == "" {
		println("Missing --file")
		os.Exit(1)
	}

	data := new(Data)
	data.Package = *packageName
	data.Items = make([]*Item, *itemCount)

	sigs := mostCommonSignatures()
	sort.Strings(sigs)
	for i, c := range sigs {
		data.Items[i] = itemFor(c)
	}

	tmpl, err := template.New("").Parse(fileTemplate)
	if err != nil {
		log.Fatal(err)
	}

	f, err := os.Create(*filePath)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	err = tmpl.Execute(f, &data)
	if err != nil {
		log.Fatal(err)
	}

	f.Seek(0, io.SeekStart)
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, *filePath, f, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	f.Seek(0, io.SeekStart)
	err = format.Node(f, fset, file)
	if err != nil {
		log.Fatal(err)
	}
}

func itemFor(signature string) *Item {
	if len(signature) < 3 || signature[1:3] != "@:" {
		panic("Can't handle methods that are not object methods")
	}

	name := signature[0:1] + signature[3:]
	name = strings.ReplaceAll(name, "@", "X")
	name = strings.ReplaceAll(name, "#", "Y")
	name = strings.ReplaceAll(name, ":", "Z")
	name = strings.ReplaceAll(name, "^", "P")
	name = strings.ReplaceAll(name, "*", "R")

	item := new(Item)
	item.Name = name
	item.Encoding = signature
	item.VoidReturn = signature[0] == 'v'
	item.C.Return = cTypeFor(signature[0])
	item.Go.Return = goTypeFor(signature[0])
	item.ObjectReturn = isObject(signature[0])

	if !item.VoidReturn {
		item.ConvertReturn = fmt.Sprintf(cToGoFor(signature[0]), "r")
	}

	params := []byte(signature[3:])
	item.DirectParams = make([]string, len(params))
	item.C.Params = make([]string, len(params))
	item.C.Call = make([]string, len(params))
	item.Go.Params = make([]string, len(params))
	item.Go.Call = make([]string, len(params))
	for i, p := range params {
		arg, goType, cType := fmt.Sprintf("a%d", i), goTypeFor(p), cTypeFor(p)
		item.DirectParams[i] = fmt.Sprintf(goToGoFor(p), fmt.Sprintf("args[%d]", i), goType)
		item.C.Params[i] = cType + " " + arg
		item.C.Call[i] = arg
		item.Go.Params[i] = arg + " " + goType
		item.Go.Call[i] = fmt.Sprintf(goToCFor(p), arg)

		if p == '*' {
			item.Conversions = append(item.Conversions, fmt.Sprintf("%s := C.CString(%s); defer C.free(unsafe.Pointer(%[1]s))", item.Go.Call[i], arg))
		}
	}

	return item
}

func cTypeFor(r byte) string {
	switch r {
	case '@':
		return "id"
	case '#':
		return "Class"
	case ':':
		return "SEL"
	case 'c':
		return "char"
	case 'C':
		return "unsigned char"
	case 's':
		return "short"
	case 'S':
		return "unsigned short"
	case 'i':
		return "int"
	case 'I':
		return "unsigned int"
	case 'l':
		return "long"
	case 'L':
		return "unsigned long"
	case 'q':
		return "long long"
	case 'Q':
		return "unsigned long long"
	case 'f':
		return "float"
	case 'd':
		return "double"
	case 'b':
		panic("Can't handle bitfield types")
	case 'B':
		return "bool"
	case 'v':
		return "void"
	case '?':
		panic("Can't handle undefined types")
	case '^':
		return "void *"
	case '*':
		return "char *"
	case '%':
		panic("Can't handle atom types")
	case '[':
		panic("Can't handle array types")
	case '(':
		panic("Can't handle union types")
	case '{':
		panic("Can't handle struct types")
	case '!':
		panic("Can't handle vector types")
	default:
		panic(fmt.Sprintf("Can't handle unknown type code %q", r))
	}
}

func goTypeFor(r byte) string {
	switch r {
	case '@':
		return "Object"
	case '#':
		return "Class"
	case ':':
		return "Selector"
	case 'c':
		return "Char"
	case 'C':
		return "UChar"
	case 's':
		return "Short"
	case 'S':
		return "UShort"
	case 'i':
		return "Int"
	case 'I':
		return "UInt"
	case 'l':
		return "Long"
	case 'L':
		return "ULong"
	case 'q':
		return "LongLong"
	case 'Q':
		return "ULongLong"
	case 'f':
		return "float32"
	case 'd':
		return "float64"
	case 'b':
		panic("Can't handle bitfield types")
	case 'B':
		return "bool"
	case 'v':
		return ""
	case '?':
		panic("Can't handle undefined types")
	case '^':
		return "unsafe.Pointer"
	case '*':
		return "string"
	case '%':
		panic("Can't handle atom types")
	case '[':
		panic("Can't handle array types")
	case '(':
		panic("Can't handle union types")
	case '{':
		panic("Can't handle struct types")
	case '!':
		panic("Can't handle vector types")
	default:
		panic(fmt.Sprintf("Can't handle unknown type code %q", r))
	}
}

func goToCFor(r byte) string {
	switch r {
	case '@':
		return "objectGo2C(%s)"
	case '#':
		return "classGo2C(%s)"
	case ':':
		return "selectorGo2C(%s)"
	case 'c':
		return "C.char(%s)"
	case 'C':
		return "C.uchar(%s)"
	case 's':
		return "C.short(%s)"
	case 'S':
		return "C.ushort(%s)"
	case 'i':
		return "C.int(%s)"
	case 'I':
		return "C.uint(%s)"
	case 'l':
		return "C.long(%s)"
	case 'L':
		return "C.ulong(%s)"
	case 'q':
		return "C.longlong(%s)"
	case 'Q':
		return "C.ulonglong(%s)"
	case 'f':
		return "C.float(%s)"
	case 'd':
		return "C.double(%s)"
	case 'b':
		panic("Can't handle bitfield types")
	case 'B':
		return "C.bool(%s)"
	case '?':
		panic("Can't handle undefined types")
	case '^':
		return "unsafe.Pointer(%s)"
	case '*':
		return "c_%s"
	case '%':
		panic("Can't handle atom types")
	case '[':
		panic("Can't handle array types")
	case '(':
		panic("Can't handle union types")
	case '{':
		panic("Can't handle struct types")
	case '!':
		panic("Can't handle vector types")
	default:
		panic(fmt.Sprintf("Can't handle unknown type code %q", r))
	}
}

func goToGoFor(r byte) string {
	switch r {
	case '@':
		return "asObject(%[1]s)"
	case '#':
		return "asClass(%[1]s)"
	case ':':
		return "asSelector(%[1]s)"
	case '*', '^':
		return "(%[1]s).(%[2]s)"
	case 'c', 's', 'i', 'l', 'q':
		return "%[2]s(asInt(%[1]s))"
	case 'C', 'S', 'I', 'L', 'Q':
		return "%[2]s(asUint(%[1]s))"
	case 'f', 'd':
		return "%[2]s(asFloat(%[1]s))"
	case 'B':
		return "%[2]s(asBool(%[1]s))"
	case 'b':
		panic("Can't handle bitfield types")
	case '?':
		panic("Can't handle undefined types")
	case '%':
		panic("Can't handle atom types")
	case '[':
		panic("Can't handle array types")
	case '(':
		panic("Can't handle union types")
	case '{':
		panic("Can't handle struct types")
	case '!':
		panic("Can't handle vector types")
	default:
		panic(fmt.Sprintf("Can't handle unknown type code %q", r))
	}
}

func cToGoFor(r byte) string {
	switch r {
	case '@':
		return "objectC2Go(%s)"
	case '#':
		return "classC2Go(%s)"
	case ':':
		return "selectorC2Go(%s)"
	case 'c':
		return "Char(%s)"
	case 'C':
		return "UChar(%s)"
	case 's':
		return "Short(%s)"
	case 'S':
		return "UShort(%s)"
	case 'i':
		return "Int(%s)"
	case 'I':
		return "UInt(%s)"
	case 'l':
		return "Long(%s)"
	case 'L':
		return "ULong(%s)"
	case 'q':
		return "LongLong(%s)"
	case 'Q':
		return "ULongLong(%s)"
	case 'f':
		return "float32(%s)"
	case 'd':
		return "float64(%s)"
	case 'b':
		panic("Can't handle bitfield types")
	case 'B':
		return "bool(%s)"
	case '?':
		panic("Can't handle undefined types")
	case '^':
		return "%s"
	case '*':
		return "C.GoString(%s)"
	case '%':
		panic("Can't handle atom types")
	case '[':
		panic("Can't handle array types")
	case '(':
		panic("Can't handle union types")
	case '{':
		panic("Can't handle struct types")
	case '!':
		panic("Can't handle vector types")
	default:
		panic(fmt.Sprintf("Can't handle unknown type code %q", r))
	}
}

func isObject(r byte) bool {
	switch r {
	case '@', '#', 'v':
		return true
	case 'c', 'C', 's', 'S', 'i', 'I', 'l', 'L', 'q', 'Q', 'f', 'd', 'b', 'B', '*':
		return false
	default:
		panic(fmt.Sprintf("Can't handle unknown type code %q", r))
	}
}
